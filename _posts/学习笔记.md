

## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**



## 关于ng-class的三种用法：
**第一种：通过数据的双向绑定（不推荐）**

1.直接用classname放在 ng-class后面
```
<div ng-class="className"></div>
```

   网上各种不推荐，说实话，既然angularJS双向数据绑定这么吊，为什么不能通过这个来改变呢！查了下原由：“在controller涉及了classname在我看来是乎总是那么诡异，我希望的是controller是一个干净的纯javascript object，当然并没有明文固定不能够这么使用的，而且反而我觉得这样非常的方便，让html中元素想怎么变就怎么变！同理中的img元素中的src就不可以通过别的来改变，但是通过这种方式就是可以的!
   
**第二种：通过对象数组**

1.通过对象数组的语法解析
```
<div ng-class="{true:‘zhende‘,false:‘jiade‘}[className]"></div>
```
实现很简单，就是当className为真的时候class为zhende，相反则为jiade。但是有一点不好的只能够让一个元素拥有两种状态，虽然这么说！简单、直观！

**第三种：通过key/value** 
```
 <div ng-class="{‘selectClass‘:select,‘choiceClass‘:choice,‘haha‘:lala}"></div>
```
当lala为true的时候，class则为haha，个人认为这个是比较推荐的，可以弥补第二种方式的点点遗憾~
所以基本上，angularJS中ng-class的实现就这三种方式~

**ng-class中遇到的一些bug：**

   1.关于ng-class的不生效问题
      这个问题可能是因为几个不一样的点导致的，本人觉得需要注意的点就是以下两点：
       1. class中一些属性存在优先级关系的时候可以在想加样式的属性后面加一个 !important.
       2. 在angualarjs重1.3版本到1.6.9的版本升级的时候应为compile服务的升级，angularjs将ng-class后面
	   的属性作为一个对象传递对象中只要有一个值为undifine就会导致ng-class不生效，这种BUG主要发生在一些
	   版本比较老的浏览器中。版本较新的浏览器会智能识别这些东西。
	   
**IE/Fire Fox/Chrome/Edge/ 兼容性的問題**
        Event path：
		      chrome: support e.path/e.composedPath()
			  Fire Fox: support e.composedPath()
			  IE/Edge: does not support e.path and e.composedPath()
			  If the brower does not support the value, we can know the value detail and code about it.
			  So we should define a function as follow:
```
	function composedPath (el) {
		var path = [];
	
		while (el) {     
				path.push(el); 
				if (el.tagName === 'HTML') {     
					path.push(document);
					path.push(window);   
					return path;
			   }
	           el = el.parentElement;
	    }
	}
```

**python数据清洗时注意格式化**
  最近在用python爬數據的時候遇到了一個ascll碼的問題。在對爬去的數據進行清洗的時候要注意的問題有數據格式化，通用的問題。
	  
	  
**AngularJs中$watch的執行**	  
在digest执行时，如果watch观察的的value与上一次执行时不一样时，就会被触发。


**mysql优化（三）–explain分析sql语句执行效率**

Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。
Explain语法：explain select … from … [where …]
例如：explain select * from news;
输出：

+----+-------------+-------+-------+-------------------+---------+---------+-------+------
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
+----+-------------+-------+-------+-------------------+---------+---------+-------+------
下面对各个属性进行了解：
1、id：这是SELECT的查询序列号
2、select_type：select_type就是select的类型，可以有以下几种：
SIMPLE：简单SELECT(不使用UNION或子查询等)
PRIMARY：最外面的SELECT
UNION：UNION中的第二个或后面的SELECT语句
DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询
UNION RESULT：UNION的结果。
SUBQUERY：子查询中的第一个SELECT
DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询
DERIVED：导出表的SELECT(FROM子句的子查询)
3、table：显示这一行的数据是关于哪张表的
4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。
结果值从好到坏依次是：
system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。
5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行
6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL
7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好
8、ref：显示使用哪个列或常数与key一起从表中选择行。
9、rows：显示MySQL认为它执行查询时必须检查的行数。
10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。
Distinct
一旦MYSQL找到了与行相联合匹配的行，就不再搜索了
Not exists
MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，
就不再搜索了
Range checked for each
Record（index map:#）
没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
Using filesort
看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行
Using index
列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候
Using temporary
看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上
Using where
使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题
其他一些Tip：
当type 显示为 “index” 时，并且Extra显示为“Using Index”， 表明使用了覆盖索引。



Spring Boot + Mybatis + MySql 整合
1. pom.xml添加依賴
<!-- 添加 MyBatis -->

    <dependency>
    	<groupId>org.mybatis.spring.boot</groupId>
    	<artifactId>mybatis-spring-boot-starter</artifactId>
    	<version>1.2.0</version>
    </dependency>

<!-- 添加 MySQL -->

    <dependency>
    	<groupId>mysql</groupId>
    	<artifactId>mysql-connector-java</artifactId>
    	<version>5.1.41</version>
    </dependency>

2. application.properties 數據庫配置

    spring.datasource.url=jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=UTF-8
    spring.datasource.username=root
    spring.datasource.password=123
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver

**常用的javaScript正则表达式(收藏)**

1 用户名正则
//用户名正则，4到16位（字母，数字，下划线，减号）
var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;
//输出 true
console.log(uPattern.test("iFat3"));
2 密码强度正则
//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符
var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;
//输出 true
console.log("=="+pPattern.test("iFat3#"));
3 整数正则

//正整数正则
var posPattern = /^\d+$/;
//负整数正则
var negPattern = /^-\d+$/;
//整数正则
var intPattern = /^-?\d+$/;
//输出 true
console.log(posPattern.test("42"));
//输出 true
console.log(negPattern.test("-42"));
//输出 true
console.log(intPattern.test("-42"));
4 数字正则

可以是整数也可以是浮点数

//正数正则
var posPattern = /^\d*\.?\d+$/;
//负数正则
var negPattern = /^-\d*\.?\d+$/;
//数字正则
var numPattern = /^-?\d*\.?\d+$/;
console.log(posPattern.test("42.2"));
console.log(negPattern.test("-42.2"));
console.log(numPattern.test("-42.2"));
5 Email正则

//Email正则
var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;
//输出 true
console.log(ePattern.test(<a rel="external nofollow" href="mailto:65974040@qq.com">65974040@qq.com</a>));
6 手机号码正则

//手机号正则
var mPattern = /^[1][3][0-9]{9}$/;
//输出 true
console.log(mPattern.test("13900000000"));
7 身份证号正则

//身份证号（18位）正则
var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;
//输出 true
console.log(cP.test("11010519880605371X"));
8 URL正则

//URL正则
var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;
//输出 true
console.log(urlP.test(<a rel="external nofollow" href="http://42du.cn">http://42du.cn</a>));
9 IPv4地址正则

//ipv4地址正则
var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
//输出 true
console.log(ipP.test("115.28.47.26"));
10 十六进制颜色正则

//RGB Hex颜色正则
var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;
//输出 true
console.log(cPattern.test("#b8b8b8"));
11 日期正则

//日期正则，简单判定,未做月份及日期的判定
var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;
//输出 true
console.log(dP1.test("2017-05-11"));
//输出 true
console.log(dP1.test("2017-15-11"));
//日期正则，复杂判定
var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;
//输出 true
console.log(dP2.test("2017-02-11"));
//输出 false
console.log(dP2.test("2017-15-11"));
//输出 false
console.log(dP2.test("2017-02-29"));
12 QQ号码正则

//QQ号正则，5至11位
var qqPattern = /^[1-9][0-9]{4,10}$/;
//输出 true
console.log(qqPattern.test("65974040"));
13 微信号正则

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线
var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;
//输出 true
console.log(wxPattern.test("RuilongMao"));
14 车牌号正则

//车牌号正则
var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;
//输出 true
console.log(cPattern.test("京K39006"));
15 包含中文正则

//包含中文正则
var cnPattern = /[\u4E00-\u9FA5]/;
//输出 true
console.log(cnPattern.test("42度"));

how to generate csr by using openssl:
https://www.trustauth.cn/csr/593.html

how to require ssl cert from CA:
https://blog.csdn.net/dqsewxl/article/details/81188777

import java.util.Optional;
生成 随机素数
openssl prime -generate -bits 32

组件复用，要确定复用内容的可重用行，如果有些方法不需要复用建议将其变成参数。-------------------------    解耦大法好


newton project 的 maven bulid 過程詳解

如何实现空格替换为"%20"

1. 直接用url编码方法可把空格转义为"%20";
function replaceSpace(str) {
    return encideURIComponment(str); // encode the str js lib
}


**别动不动就遍历：** 
   当你在用遍历的方式时可以考虑以下的问题
   1. 数据源在哪？
   2. 数据流向？
   3. 中间数据操作尽量简单
   
   性能问题真是一道坎啊 没有优化的sence
   
   
   **没有胆子去剖析真理**

